//
// Source code recreated from a .class file by IntelliJ IDEA
// (powered by Fernflower decompiler)
//

package com.qualcomm.ftcrobotcontroller.opmodes;

import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
import com.qualcomm.robotcore.hardware.DeviceInterfaceModule;
import com.qualcomm.robotcore.hardware.IrSeekerSensor;
import com.qualcomm.robotcore.util.RobotLog;
import com.qualcomm.robotcore.util.TypeConversion;
import java.util.concurrent.locks.Lock;

public class LinearI2cAddressChange extends LinearOpMode {
    public static final int ADDRESS_SET_NEW_I2C_ADDRESS = 112;
    public static final byte TRIGGER_BYTE_1 = 85;
    public static final byte TRIGGER_BYTE_2 = -86;
    public static final byte IR_SEEKER_V3_FIRMWARE_REV = 18;
    public static final byte IR_SEEKER_V3_SENSOR_ID = 73;
    public static final byte IR_SEEKER_V3_ORIGINAL_ADDRESS = 56;
    public static final byte MANUFACTURER_CODE = 77;
    public static final byte FIRMWARE_REV = 18;
    public static final byte SENSOR_ID = 73;
    public static final int READ_MODE = 128;
    public static final int ADDRESS_MEMORY_START = 0;
    public static final int TOTAL_MEMORY_LENGTH = 12;
    public static final int BUFFER_CHANGE_ADDRESS_LENGTH = 3;
    int port = 3;
    byte[] readCache;
    Lock readLock;
    byte[] writeCache;
    Lock writeLock;
    int currentAddress = 56;
    int newAddress = 66;
    DeviceInterfaceModule dim;

    public LinearI2cAddressChange() {
    }

    public void runOpMode() throws InterruptedException {
        this.dim = (DeviceInterfaceModule)this.hardwareMap.deviceInterfaceModule.get("dim");
        this.readCache = this.dim.getI2cReadCache(this.port);
        this.readLock = this.dim.getI2cReadCacheLock(this.port);
        this.writeCache = this.dim.getI2cWriteCache(this.port);
        this.writeLock = this.dim.getI2cWriteCacheLock(this.port);
        IrSeekerSensor.throwIfModernRoboticsI2cAddressIsInvalid(this.newAddress);
        this.waitForStart();
        this.performAction("read", this.port, this.currentAddress, 0, 12);

        while(!this.dim.isI2cPortReady(this.port)) {
            this.telemetry.addData("I2cAddressChange", "waiting for the port to be ready...");
            this.sleep(1000L);
        }

        this.dim.readI2cCacheFromController(this.port);
        int count = 0;
        int[] initialArray = new int[]{128, this.currentAddress, 0, 12, 18, 77, 73};

        while(!this.foundExpectedBytes(initialArray, this.readLock, this.readCache)) {
            this.telemetry.addData("I2cAddressChange", "Confirming that we\'re reading the correct bytes...");
            this.dim.readI2cCacheFromController(this.port);
            this.sleep(1000L);
            ++count;
            if(count >= 10) {
                this.telemetry.addData("I2cAddressChange", String.format("Looping too long with no change, probably have the wrong address. Current address: %02x", new Object[]{Integer.valueOf(this.currentAddress)}));
                this.hardwareMap.irSeekerSensor.get(String.format("Looping too long with no change, probably have the wrong address. Current address: %02x", new Object[]{Integer.valueOf(this.currentAddress)}));
            }
        }

        this.performAction("write", this.port, this.currentAddress, 112, 3);
        this.waitOneFullHardwareCycle();
        this.writeNewAddress();
        this.dim.setI2cPortActionFlag(this.port);
        this.dim.writeI2cCacheToController(this.port);
        this.telemetry.addData("I2cAddressChange", "Giving the hardware some time to make the change...");

        for(int confirmArray = 0; confirmArray < 5000; ++confirmArray) {
            this.waitOneFullHardwareCycle();
        }

        this.dim.enableI2cReadMode(this.port, this.newAddress, 0, 12);
        this.dim.setI2cPortActionFlag(this.port);
        this.dim.writeI2cCacheToController(this.port);
        int[] var4 = new int[]{128, this.newAddress, 0, 12, 18, 77, 73};

        while(!this.foundExpectedBytes(var4, this.readLock, this.readCache)) {
            this.telemetry.addData("I2cAddressChange", "Have not confirmed the changes yet...");
            this.dim.readI2cCacheFromController(this.port);
            this.sleep(1000L);
        }

        this.telemetry.addData("I2cAddressChange", "Successfully changed the I2C address." + String.format("New address: %02x", new Object[]{Integer.valueOf(this.newAddress)}));
    }

    private boolean foundExpectedBytes(int[] byteArray, Lock lock, byte[] cache) {
        try {
            lock.lock();
            boolean allMatch = true;
            StringBuilder s = new StringBuilder(1200);
            String mismatch = "";
            int i = 0;

            while(true) {
                if(i < byteArray.length) {
                    s.append(String.format("expected: %02x, got: %02x \n", new Object[]{Integer.valueOf(TypeConversion.unsignedByteToInt((byte)byteArray[i])), Byte.valueOf(cache[i])}));
                    if(TypeConversion.unsignedByteToInt(cache[i]) == TypeConversion.unsignedByteToInt((byte)byteArray[i])) {
                        ++i;
                        continue;
                    }

                    mismatch = String.format("i: %d, byteArray[i]: %02x, cache[i]: %02x", new Object[]{Integer.valueOf(i), Integer.valueOf(byteArray[i]), Byte.valueOf(cache[i])});
                    allMatch = false;
                }

                RobotLog.e(s.toString() + "\n allMatch: " + allMatch + ", mismatch: " + mismatch);
                boolean var11 = allMatch;
                return var11;
            }
        } finally {
            lock.unlock();
        }
    }

    private void performAction(String actionName, int port, int i2cAddress, int memAddress, int memLength) {
        if(actionName.equalsIgnoreCase("read")) {
            this.dim.enableI2cReadMode(port, i2cAddress, memAddress, memLength);
        }

        if(actionName.equalsIgnoreCase("write")) {
            this.dim.enableI2cWriteMode(port, i2cAddress, memAddress, memLength);
        }

        this.dim.setI2cPortActionFlag(port);
        this.dim.writeI2cCacheToController(port);
        this.dim.readI2cCacheFromController(port);
    }

    private void writeNewAddress() {
        try {
            this.writeLock.lock();
            this.writeCache[4] = (byte)this.newAddress;
            this.writeCache[5] = 85;
            this.writeCache[6] = -86;
        } finally {
            this.writeLock.unlock();
        }

    }
}
